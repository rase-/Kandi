\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{lmodern}
\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{Mutaatiotestaus -- working title}
\author{Tony Kovanen}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
A.1 [Introductory and Survey],\\
I.7.m [Document and text processing]}}

\keywords{Ohjelmistojen testaus, mutatointi, testidatan generointi}

\mytableofcontents

\section{Johdanto}
Ohjelmistoja tuotettaessa on tärkeää verifioida ohjelmiston eri komponenttien toimivuus ja niiden yhteensopivuus. Testauksen rooli ohjelmistotuotantoprosessissa vie potentiaalisesti paljon resursseja suhteessa itse tuotteen toteutukseen, mutta se myös torjuu tehokkaasti viallista ja bugista koodia~\cite{}. Vaikka testaus ei anna täysin objektiivista totuutta siitä toimiiko ohjelmisto kuten on odotettu, tai täsmälleen sille asetettujen vaatimusten mukaan, se kasvattaa ohjelmoijien luottamusta tuotteen laatuun. Kattavien testien läsnäollessa voidaan myös huoletta lisätä uusia toiminnallisuuksia ohjelmistoon ja refaktoroida ohjelmakoodia, sillä epäonnistuvat testit huomauttavat vanhan toiminnallisuuden, tai komponenttien yhteensopivuuden rikkomisesta. 

\subsection{Testauksen tasot}
Yksittäisten komponenttien verifiointi voidaan tehdä yksittötesteillä. Näillä voidaan varmistaa olio-ohjelmointikielissä yksittäisten luokkien ja niiden metodien toimivuus. Vastaavia testejä voidaan kirjoittaa myös esimerkiksi funktionaalisilla ohjelmointikielillä, joissa yksikkötestit testaavat yksittäisten funktioiden toiminnallisuutta. Kattavien yksikkötestien läsnäollessa refaktorointi on helpompaa, sillä jokaisen muutoksen jälkeen voidaan ajaa yksikkötestit, ja saada välitöntä palautetta siitä toimiiko muutettu komponentti vieläki olennaisesti samalla tavalla. Yksikkötesteillä tullaan usein testattua myös jossain määrin komponenttien yhteistoimintaa, sillä oliot usein kapseloivat sisäänsä toisia olioita, jolloin tämän olion toimivuus riippuu sen kapseloimien olioiden toimivuudesta. Integraatiotesteillä testataan komponenttien toimivuus yhdessä. Tämä tapahtuu usein simuloimalla kokonaisia ohjelmiston toimintoja. Hyväksymistestit ovat käyttötapaustason testejä, joilla ohjelmistolle suoritetaan kokonainen käyttötapaus, jonka tulos evaluoidaan. Tässä tutkielmassa keskitytään yksikkötestien kattavuuden mittaamiseen.

\subsection{Testauskattavuus}
Niin yksikkö- kuin integraatiotestien yhteydessä puhutaan usein testauskattavuudesta. Testauskattavuus on mitta siitä, miten hyvin ohjelmalle kirjoitetut testit kattavat kirjoitetun ohjelmakoodin. Tässä tapauksessa se, että jotkin testit kattavat ohjelman tarkoittavat sitä, että virheellinen ohjelma huomataan siten, että yksi tai useampi testi epäonnistuu. Kattavuuden mittana tunnetuimmat ja yleisimmät ovat rivikattavuus ja haarakattavuus. Näitä kattavuusmetriikoita tarjoavat useimmat testauskattavuustyökalut.

Rivikattavuudessaa tarkastellaan millä annetun ohjelman riveillä käydään testejä suoritettaessa. Jos testien suorituksen aikana suoritettiin jokainen ohjelmakoodin rivi, on testikattavuus 100\%. Käytännössä rivikattavuus lasketaan siis kaavalla: $\frac{\text{suoritetut rivit}}{\text{rivien määrä}}$.

Haarakattavuus mittaa eri kontrollirakenteista syntyvien haarojen kattavuuden, eli se kertoo prosentuaalisesti sen määrän eri kontrollihaaroista, minkä ohjelmakoodin testit ovat suorittaneet testattavasta komponentista. Useimmat testauskattavuustyökalut tarjoavat molemmat näistä kattavuusmetriikoista. Jotkut työkalut tarjoavat myös mitan siitä, kuinka moni totuusarvo on evaluoitunut sekä todeksi että epätodeksi.

Mutaatiokattavuus on eräs metriikka jolla pyritään semanttisempaan analyysin testien kattavuudesta. Mutaatiotestauksen tavoite on saada selville kuinka kattavasti määritellyt testit löytävät ohjelmakoodiin indusoitavia pieniä muutoksia. Tämä takaa sen, että mutaatiotestauksella saadaan tuotettua laadukkaampia ohjelmistoja. Rivi- ja haarakattavuutta saadaan lisättyä testeillä jotka eivät välttämättä edes testaa mitään, kunhan tietyt rivit suoritetaan ohjelmakoodista, ja tällaisia takeita ei ole. Tässä tutkielmassa esitellään mutaatiotestauksen idea, sen menetelmät, sovellukset ja heikkoudet. Kaikista kattavuuksista on usein tarjolla pelkän metriikan tuottaman kattavuusluvun lisäksi myös raportti, josta kattavuuden ulkopuolelle jäävät rivit ja haarat tulevat esille. Myös useat mutaatiokattavuutta tukevat testikehykset näyttävät vastaavanlaisen raportin, jossa ohjelmoijalle näytetään se osa koodista, johon tehtyä muutosta ei havaittu sille kirjoitetuilla testeillä. Näiden raporttien ulkoasuun perehdytään tarkemmin tutkielman lopussa, jossa esitellään joitakin testauskattavuustyökaluja toiminnassa.

\section{Mutaatiotestaus}
Mutaatiotestaus on menetelmä, jolla voidaan mitata jonkin testijoukon virheenhavaitsemiskykyä tavoitteena kehittää sellainen testijoukko, joka on mahdollisimman kattava. Mutaatiotestaus tapahtuu ohjelmalle suoritettavalla testaussyklillä. Ensin ohjelman testit ajetaan alkuperäiselle lähdekoodille. Jos jokin testi epäonnistuu, se tulee korjata ennen jatkamista. Tarve tähän tarkistukeen on ilmeinen. Jos alkuperäinen ohjelma ei läpäise jotakin testiä, ei tämän testin epäonnistuneenä pysyminen anna takeita siitä, ettei ohjelman toiminnallisuus olisi olennaisesti muuttunut.

Seuraavaksi ohjelmakoodista tehdään useita kopioita, joissa kussakin jokin yksityiskohta, tai joitain useita yksityiskohtia on muutettu niin sanotuilla mutaatioilla. Näitä kopioita kutsutaan mutanteiksi, jotka esittävät mahdollisia virheellisiä variantteja alkuperäisestä ohjelmasta. Testit, jotka on annettu mutaatiosyklin parametreina, suoritetaan jokaiselle mutantille. Jos jokin testi epäonnistuu jonkin mutantin kohdalla, tämä leimataan tapetuksi, koska testi tunnisti koodiin tehdyn muutoksen. Jos taas mikään testi ei epäonnistu, mutantti leimataan selviytyneeksi, sillä mikään testi ei tunnistanut muutosta. Selviytyneiden mutanttien ajatellaan kielivän puutteesta testeissä. Jokaisesta mutantista otetaan usein talteen mutaatiokohta, sekä mutaatio. Näin selviytynyeitä mutantteja voidaan tarkastella ja testejä parannella näitä tietoja apuna käyttäen. Ne antavat usein vihjeitä siitä mitä testeissä on jäänyt testaamatta. Mutaatiotestauksen mittana käytetään mutaatiokattavuutta, joka lasketaan yksinkertaisesti kaavalla $\frac{\text{tapetut mutantit}}{\text{mutanttien kokonaismäärä}}$. Tämä vaihe pitää suorittaa manuaalisesti: ohjelmoijat tarkastelevat selviytyneitä mutantteja ja päättävät mitä testeihin tulee lisätä.

Mutaatiosykliin ollaan ehdoteltu parannuksia. On selvää, että parannuksille on tilaa, sillä testaussykli sisältää hyvin työlään manuaalisen vaiheen. Parannuksia tutkitaan, ja tulevaisuudessa toivotaan seuraavaa modifikaatiota sykliin: kun selviytyvät mutantit ollaan löydetty generoidaan niiden perusteelta testejä automaattisesti. Toistetaan sitten sykliä alusta lähtien niin kauan kunnes yksikään mutantti ei jää henkiin~\cite{}. Tähän sykliin pääseminen ei ole kuitenkaan vielä mahdollista useistakin syistä. Näihin syihin palataan myöhemmin käsiteltäessä mutaatiotestauksen heikkouksia. 

\section{Mutaatiot}
Mutaatiotestaus perustuu siihen, että ohjelmakoodiin indusoidaan mutaatoita, joita ohjelmalle määriteltyjen testien tulisi huomata. Sana mutaatio tulee perinnöllisyystieteen termistä mutaatio, missä sillä tarkoitetaan muutosta geeniin, jossa yksi geenin kemiallinen komponentti, nulkeotidi, on vaihtunut joksikin toiseksi, on deletoitu sekvenssistä, tai on insertoitu sekvenssiin. Määritellään mutaatioiden konsepti äärellisille automaateille, sekä yleistetään ne sitten yksittäisten ohjelmointikielten tapauksiin.

\begin{figure}[here]
\caption{Äärellinen automaatti $O$ joka hyväksyy minkä tahansa lukuun $1$ päättyvän aakkoston $\Sigma = \{0,1\}$ sekvenssin.}
\label{fig:nfa}
\includegraphics{automaatit/nfa.png}
\end{figure}

\begin{figure}[here]
\caption{Ensimmäisen asteen mutantti $m1$ automaatista $O$, jossa siirtymä tilasta $b$ tilaan $a$ on lisätty aakkosella $1$}
\label{fig:m1}
\includegraphics{automaatit/m1.png}
\end{figure}

\begin{figure}[here]
\caption{Ensimmäisen asteen mutantti $m2$ automaatista $O$, jossa siirtymä tilasta $a$ tilaan $b$ korvattu tyhjällä siirtymällä}
\label{fig:m2}
\includegraphics{automaatit/m2.png}
\end{figure}

\subsection{Mutaatiot äärellisillä automaateilla}
Äärellisten automaattien tapaukseen mutaatoiden määrittely on helppoa. Olkoon $\Sigma=\{0,1\}$ aakkosto. Voimme nyt määritellä tälle aakkostolle useita eri äärellisiä automaatteja, jotka hyväksyvät vain jotkin tietyt merkkijonot, jotka koostuvat aakkosista $\sigma \in \Sigma$. Eräs tällainen automaatti löytyy kuvasta~\ref{fig:nfa}, jonka aloitustila on tila $a$ ja hyväksyvä tila on $b$. Kyseinen automaatti hyväksyy minkä tahansa tilasiirtymäsekvenssin, joka loppuu aakkoseen $\sigma = 1$. Määritellään nyt myös joukko mutaatioita $M$. Jokainen mutaatio $m\in M$ on kuvaus, joka korvaa jonkin olemassaolevan tilasiirtymän toisella, poistaa tilasiirtymän, tai lisää tilasiirtymän. Näitä funktioita kutsutaan mutaatio-operaattoreiksi. Jokainen mutaatio $m$ on siis kuvaus aakkoston $\Sigma$ äärellisten automaattien joukolta itselleen, jossa tämä mutaatio tekee jonkn muutoksen, tai joitakin muutoksia annettuun äärelliseen automaattiin. Tarkastellaan joitain kuvan~\ref{fig:nfa} epädeterministisen äärellisen automaatin ensimmäisen asteen mutantteja eli mutaatioita, jotka sisältävät vain yhden edellämainitun muutoksen alkuperäiseen automaattiin. 

Kuva~\ref{fig:m1} ja ~\ref{fig:m2} sisältävät eräät ensimmäisen asteen mutantit alkuperäisestä automaatista. Kuvan~\ref{fig:m1} mutantti on eroaa alkuperäisestä automaatista siten, että toinen yhteys tilasta $b$ tilaan $a$ on lisätty. Mutantti kuvassa~\ref{fig:m2} eroaa alkuperäisestä automaatista siten, että yhteys tilasta $a$ tilaan $b$ on vaihdettu tyhjäksi siirtymäksi. Kun tarkastelemme millaisia tilasiirtymäsekvenssejä nämä mutanttiautomaatit hyväksyvät, huomaamme, että kuvan~\ref{fig:m2} automaatti ei ole funktionaalisesti sama kuin alkuperäinen automaatti~\ref{fig:nfa}. Kuvan~\ref{fig:m2} mutantti hyväksyy minkä tahansa tilasiirtymäsekvenssin annetulla aakkostolla $\Sigma$, sillä tyhjä tilasiirtymä vie hyväksyvään tilaan $b$. Tilasta $b$ voidaan siirtyä nollasiirtymällä tilaan $a$, tai ykkössiirtymällä itseensä. Mikäli siirrytään tilaan $a$, voidaan pysyä tässä tilassa nollasiirtymällä, tai siirtyä hyväksyvään tilaan tyhjällä siirtymällä. Huomataan siis, että $L(O) \neq L(m2)$, eli alkuperäisen automaatin määrittelemä kieli $L(0)$ ei ole sama kuin kuvan~\ref{fig:m2} määrittelä kieli $L(m2)$.

Kun tarkastellaan kuvan~\ref{fig:m1} mutanttia $m1$, huomataan, että se hyväksyy täsmälleen samat merkkijonot kuin alkuperäinen automaatti $O$, eli $L(O) = L(m1)$. Mutantissa $m1$ on kaikki samat tilasiirtymät kuin automaatissa $O$, joten se hyväkyy vähintään kaikki samat sekvenssit, sillä epädeterminismin johdosta mikä tahansa merkkijono joka hyväksytään jollakin mahdollisella tilasiirtymäjonolla hyväksytään. Tämä automaatti ei myöskään hyväksy mitään muita merkkijonoja, sillä lisätty tilasiirtymä ei tuo mitään uusia mahdollisuuksia siirtyä hyväksyvään tilaan $b$, vaan ainoastaan pois siitä. Päästäkseen takaisin tilaan $b$ on taas käytettävä ykkössiirtymää. Tilannetta, jolloin $L(0) = L(m1)$ kutsutaan ekvivalenssiksi. Vaikka $O \neq m1$, ovat ne funktionaalisesti samat, eli niiden kielet ovat samat.
 
\subsection{Mutaatiot ohjelmointikielissä}
Olkoon $O$ jokin alkuperäinen, jollain ohjelmointikielellä toteutettu ohjelma. Nyt $M$ on joukko mutantteja ja jokainen $m\in M$ on sama ohjelma, mutta siihen on tehty jokin tai joitakin syntaktisia muutoksia. Mutaatoiden luonto riippuu usein käyteystä ympäristöstä. On selvää, että täysin samat mutaatiot eivät käy sekä olio-ohjelmointikieliin, että puhtaasti funktionaalisiin ohjelmointikieliin.

Mutantit tuotetaan ohjelmointikieliin ns. mutaatio-operaattoreilla. Mutaatio-operaattori on funktio joka tuottaa mutaation annettuun ohjelmaan $O$. Idea mutaatiolle on täysin sama kuin äärellisille automaateille. Voidaan korvata, lisätä tai poistaa elementtejä ohjelmakoodista. Käytettävät mutaatio-operaattorit ovat imperatiivisissa ohjelmointikielissä pääosin samat. Agrawal ja kumppanit listaavat 76 C-kielen mutaatio-operaattoria. Nämä mutaatio-operaattorit pätevät pääosin siis kaikkiin C-pohjaisiin ohjelmointikieliin, kuten Javaan ja PHP:hen, sekä karkeasti muihin imperatiivisiin ohjelmointikieliin. Ne ovat jaettu seuraaviin ryhmiin: lausemutaatio, operaattorimutaatio, muuttujamutaatio ja vakiomutaatio. Lausemutaatioihin luetaan mm. breakin muuttaminen continue lauseeseen, sekä aaltosulkeiden paikan muuttaminen ja goto lauseen kohteen muuttaminen. Operaattorimutaatioita ovat esimerkiksi aritmeettisten ja loogisten operaattoreiden muuttamiset toisiksi vastaavanlaisiksi operaattoreiksi. Muuttujien mutatointia ovat mm. viitteiden vaihtaminen toiseksi. Vakioiden mutatointi viittaa vakioiden arvojen päittäin vaihtamiseen, tai yksittäisen vakion arvon manipulointiin. Jokaisesta näistä mutaatiotyypistä on useita variaatioita, ja joistakin lähteistä vastaavanlaisia mutaatio-operaattoreita löytyy jopa enemmän. Proteumissa, Delamaron ja Maldonadon esittelemässä mutaatiotestikehyksessä C-kielelle, on jopa 108 mutaatio-operaattoria~\cite{}. 

\subsection{Mutaatiot eri ohjemointiparadigmoissa}
Ohjelmointikielen paradigma voi tuoda mukanaan muutoksia. Esimerkiksi Javassa, sekä muissa olio-ohjelmointikielissä voidaan kokea tarve sen olio-ohjelmointiominaisuuksiin spesifeille mutaatio-operaattoreille. Kim ja kumppanit esittelevät useita olio-ohjelmontispesifejä mutaatio-operaattoreita, kuten metodien parametrien järjestyksen vaihtaminen, ylikuormituksen poistaminen, metodien ylikirjoitus perinnässä ja monia muita~\cite{}. Näiden uusien mutaatio-operaattoreiden lisäksi luokkien sisäistä ohjelmakoodia tulee mutatoida. Mutantteja ei luoda vain pääohjelmasta, vaan jokainen ohjelman yksittäinen komponentti mutatoidaan käytössä olevia mutaatio-operaattoreita käyttäen. Mutaatio-operaattoreita voidaankin lisätä kieli ja paradigmakohtaisesti melkeinpä loputtomiin. Voidaankin miettiä onko jokainen mahdollinen operaattori tarpeellinen. Osajoukkoa kaikista mahdollisista operaattoreista, jotka tuottavat hyvän kuvan kattavuudesta tilanteessa kuin tilanteessa sanotaan riittäväksi joukoksi.

Olio-ohjelmointispesifeistä mutaatio-operaattoreista voidaan jo huomata, että paradiman vaihtuessa myös mutaatiotaktiikkaa voi joutua muuttamaan. Tämä ei päde ainoastaan olio-ohjelmointiparadigmaan. Mutatoitaessa jotain puhtaasti funktionaalista ohjelmointikieltä, kuten Clojurea voidaan joko mutatoida lähdekoodia, tai mutatoida käännöksen tuottamaa Javan tavukoodia. Tavukoodia mutatoitaessa voidaan käyttää jokseenkin vastaavanlaisia tekniikoita kuin Javalle tarkoitetuilla tavuukodia mutatoivilla mutaatioestauskehyksillä. Toisaalta voidaan myös mutatoida itse lähdekoodia, jolloin joudutaan keksimään uusia mutaatioita, koska Clojuressa ei esimeriksi ole varsinaiseti operaattoreita, vaan ainoastaan funktioita. Funktioita tulisi siis korvata toisilla funktioilla, mutta funktioiden suuri määrä tuotta ongelmia. Lisäksi Clojure on dynaamisesti tyypitetty kieli, joten sopivien korvaavien funktioiden löytäminenkin tuottaa vaikeuksia. Clojuresta voidaan myös käyttää Javan luokkia, joten voidaan kokea tarve käyttää myös olio-ohjelmointiparadigmaan liittyviä mutaatio-operaattoreita. Tutkielmassa keskitytään imperatiivisiin ohjelmointikieliin, erityisesti olio-ohjelmointikieliin kuten Java.

\section{Sovellukset}
Kuten mainittu, mutaatiotestauksen alkuperäinen ja yleinen tarkoitus on mitata kuinka hyvin jotkin annetut testit $T$ havaitsevat virheitä niiden testaamasta ohjelmasta $O$, joka voi koostua useista eri komponenteista, esimerkiksi luokista, sekä antaa vihjeitä siitä miten testejä tulisi parantaa. Kuten tutkielmassa tuotiin aiemmin esille, tämä vaihe ollaan pyrittä automatisoimaan generoimalla testit syklin suoritus kerrallaan niin, että ne tappavat kaikki mutantit.
% täs jotain tapoja ehkä lyhyesti, fokus ei kuitenkaan tutkielmassa ole näissä

\section{Mutanttien generointi ja käsittely}
Jos käytetään kaikkia mutaatio-operaattoreita, luodaan pienillekkin ohjelmille iso määrä mutantteja. Buddin mukaan generoitujen mutanttien määrä on verrannollinen dataolioiden ja data referenssien määrien tulon kanssa~\cite{}. Näiden isojen mutanttimäärien tarkastelu on hyvin epätehokasta. Wongin ja kumppaneiden mukaan mutaatiotestauksen laskenta-aika riippuu kahdesta tekijästä: tarkasteltavien testien joukon koosta $|T|$ sekä tarkasteltavien mutanttien määrästä $|M|$~\cite{}. Tämän takia mutanttien generointiin ja käsittelyyn on luotu erinäisiä helpotuksia, jotka voidaan jakaa seuraaviin kategorioihin:
\begin{enumerate}
\item Tehdään vähemmän työtä, eli redusoidaan mutanttien määrää
\item Tehdään viisaammin, eli jaetaan laskenta useammalle koneelle ja/tai prosessille
\item Tehdään nopeammin, eli generoidaan mutantit ja suoritetaan sykli nopeammin
\end{enumerate})
Esille tuotuja ensimmäisen kohdan keinoja ovat mm. selektiivinen mutatointi, mutanttien valinta, mutanttien klusterointi eli ryvästäminen, ja korkeamman asteen mutaatiot. Nämä tekniikat pyrkivät redusoimaan käsiteltävien mutanttien määrää. Redusointiongelma voidaan formalisoida seuraavaksi: yritetään löytää mutaatioiden $M$ osajoukko $M'$, jolle pätee $K(M) \~ K(M')$, missä $K$ on mutanttien tuottaman kattavuuden laskeva mutaatiokattavuusfunktio. Mutantteja redusoitaessa pyritään siis löytämään sellainen mutanttien osajoukko, joilla saadaan aikaiseksi mahdollisimman hyvin alkuperäistä joukkoa vastaava mutaatiokattavuus. Tarkoituksena on säästää aikaa, joka kuluu testien suorittamiseen jokaiselle yksittäiselle mutaatiolle. Täytyy pitää mielessä se, että tämän redusointimenetelmän on toimittava ohjelmalle yhtä hyvin myös ohjelman ja testien muuttuessa, sekä yleistyttävä muillekkin ohjelmille. Seuraavaksi käsitellään mutanttien redusointia, jonka jälkeen esitetään joitain optimointeja syklin nopeuttamiseksi. Useimmat mutaatiotestauskehykset noudattavat jossain määrin kaikkea näitä kolmea nopeutuskenoa skaalautuakseen suurillekkin ohjelmille. Näihin konkreettisiin toteutuksiin palataan tutkielman lopussa.

\subsection{Selektiivinen mutatointi}
Räjähdysmäistä mutanttien määrää voidaan rajoittaa selektiivisellä mutatoinnilla, missä käyttöön otetaan vain hyvin rajoitettu osajoukko kaikista tarjolla olevista mutaatio-operaattoreista. Nämä mutaatio-operaattorit pyritään valitsemaan niin, että saadaan efektiivisesti mahdollisimman paljon tärkeitä mutaatioita generoitua tällä osajoukolla. Selektiivisellä mutatoinnilla saadaan aikaiseksi paljon vähemmän mutantteja testattavaksi. Jos valituilla mutaatio-operaattoreilla saadaan lähes vastaavia tuloksia, voi tämä olla kannattavaa, sillä mutaatioiden käsittelyyn menevä aika kasvaa räjähdysmäisesti ohjelman koon kasvaessa. Oikeiden mutaatio-operaattoreiden valinta on kuitenkin osoittautunut vaikeaksi. Ei voida olla varmoja siitä, että samat operaattorit toimivat hyvin kaikilla eri ohjelmilla. Eräs ratkaisu on valita sellaisia mutaatioita, jotka ovat tyyppillisten ohjelmoijien tekemien virheiden kaltaisia~\cite{}. Tämä valinta on erittäin heuristinen, mutta tällä valintaperiaatteella voi odottaa vastaavia tuloksia kohdealueesta ja ohjelman koosta riippumatta. Tämä havainto perustuu niin sanottuun liitosvaikutukseen, jonka mukaan jos annetut testit $T$ havaitsevat kaikki yksinkertaiset virheet ohjelmistossa, ne havaitsevat myös suurimman osan monimutkaisemmista virheistä, jotka ovat koottavissa näistä pienistä virheistä~\cite{}. Jos valittu mutaatio-operaattoreiden joukko $\mu'$ tuottaa mutantit $M'$ siten, että $K(M) \~ K(M')$, sanotaan että $\mu'$ on riittävä joukko mutaatio-operaattoreita. Mathur esitti $N$-selektiivisen mutatoinnin~\cite{}, jolla tarkoitetaan sitä, että $N$ eniten mutaatioita tuottavaa mutaatio-operaattoria jätetään huomiotta mutanttien generoinnissa. Offutin ja kumppaneiden evaluointi $N$-selektiivisen mutatoinnin tehokkuudesta ja tarkkuudesta osoitti, että kymmenelle FORTRAN ohjelmistolle $2$-selektiivinen mutatointi ei eronnut tilastollisesti tarkkuudeltaan alkuperäisestä mutaatio-operaattorijoukosta. Kun $N$:n koko kasvoi entuudestaan huomattiin, että operaattoreiden hylkääminen yksi kerrallaan vähensi laskenta-aikaa huomattavasti enemmän kuin tarkkuutta. Jos mutaatio-operaattoreiden lähtöjoukko tai annetut ohjelmat olisivat olleet eri, oltaisiin voitu päätyä erilaiseen lopputulokseen. Operaattoreiden eliminoimisessa ei nimittäin otettu huomioon lainkaan niiden tärkeyttä. Tärkeyttä voidaan mitata useilla eri tavoilla, esimerkiksi hyödyllisten ja ekvivalenttien mutanttien suhteella.
% cite: impact of equivalent mutants

Mutaatio-operaattoreiden $\mu'$ valintaa kaikkien julistettujen operaattoreiden joukosta $\mu$ voidaan tarkastella tilastollisena ongelmana. Olkoon $\mu$ jokin ennaltamääritelty joukko mutaatio-operaattoreita. Osajoukon $\mu'$ löytäminen operaattoreista $\mu$ voidaan nähdä piirteidenvalintaongelmana siten, että jokaista mutaatio-operaattoria pidetään mutaatiotestikehyksen piirteinä. Nyt vaaditun laskennan vähentämiseksi halutaan valita vain jokin hyvän approksimaation kokonaistuloksesta antava osajoukko piirteitä. Tähän tarkoitukseen on kehitelty algoritmeja, joista eräs on pienimmän kulman regressio LARS (Least Angle Regression). Namin ja kumppanit sovelsivat LARSin muunnosta CBLARS kuuteen C-sovellukseen~\cite{}. CBLARS onnistui valitsemaan sellaisen osajoukon mutaatioista, joka tehokkaasti vähensi mutanttien määrää seitsemännessä sovelluksessa, ja osoittautui suoritetun ristiinvalidoinnin mukaan sellaiseksi, että sen pitäisi myös yleistyä hyvin. Operaattorien valintaan käytetyt kuusi ohjelmaa olivat kaikki kooltaan suhteellisen pieniä kaupalliseen ohjelmistoon verratuna, sekä olivat saman kohdealueen sovelluksia. Nämä faktat kyseenalaistavat hieman tämän tuloksen yleistymistä mille tahansa ohjelmistoille, tai edes mille tahansa C-ohjelmistoille. 

\subsection{Mutanttien valinta}
Toinen keino on vähentää tarkasteltujen mutanttien määrää. Mutanttien valinnassa generoiduista mutanteista $M$ valitaan pienempi osajoukko $M'$, joka sisältää vain ennaltasovitun määrän alkuperäisistä mutanteista. Tässä menetelmässä on selvästi ongelmansta. Satunnaisesti valitut mutantit eivät anna kovinkaan hyviä takeita siitä, että $K(M) \~ K(M')$.

\subsection{Mutanttien klusterointi}
Hussain esitteli tutkielmassaan mutanttien klusteroinnin. Tämä tekniikka perustuu ohjaamattoman koneoppimisen ryvästämiseen, jossa tarkoituksena on löytää leimaamattomasta datasta samankaltaisia ryppäitä. Pohjimmiltaan tarkoitus on sama kuin mutanttien valinnassa. Mutanttien klusteroinnissakin mutanttien kokonaisjoukosta $M$ valitaan joukko mutaatiota $M'$. Valinta ei kuitenkaan ole rajoitettu johonkin tiettyyn suhteelliseen osaan joukosta $M$, $M$ klusteroidaan mutanttien $m\in M$ tappavien testitapausten mukaan. Jokainen jonkin mutantin tappava testitapaus $t\in T$, missä $T$ on testitapausten joukko, muodostaa siis klusterin mutantteja jotka se tappaa. Jokaisesta tällaisesta klusterista $M'_{i}$ valitaan sitten vain jokin osajoukko tätä klusteria edustavia mutantteja. Osajoukko $M'$ muodostuu näistä valituista mutanteista. Näin valitaan osajoukko toisiaan muistuttavista mutanteista, jolloin saadaan varmemmin joukko $M'$ jolle pätee $K(M) \~ K(M')$. Kokeessaan Hussain käytti partitionaalista K-means algoritmia, sekä hierarkista agglomeratiivista klusterointia. Klusterointialgoritmit eivät kuitenkaan ole täysin stabiileja ja ovat potentiaalisesti hitaita suorittaa, kun $|M|$ on suuri. On siis hieman epävarmaa tuoko mutanttien klusterointi juurikaan nopeutusta mutaatiokattavuuden saamiseksi. Potentiaalisesti se voi jopa hidastaa testien suoritusta mutanteille. Se voi kuitenkin tehokkaasti vähentää niiden mutanttien määrää, joita ohjelmoijien pitää tarkastella.

\subsection{Korkeamman asteen mutaatiot}
Korkeamman asteen mutaatioiden ideana on käyttää mutantteja, jotka koostuvat useammasta vaikeammin tapettavasta ensimmäisen asteen mutantista. Korkeamman asteen mutantit ovat mutantteja, joihin on sovellettu useampaa mutaatio-operaattoria. Jokainen korkeamman asteen mutantti on siis jaoteltevissa niihin ensimmäisen asteen mutantteihin, joihin jokaista tämän mutantin yksittäistä mutaatio-operaattoria on sovellettu. Vaikeammin tapettavia korkeamman asteen mutantteja käytettäessä saadaan aikaan uusi mutanttijoukko $M'$, jolle pätee $|M| > |M'|$. Sopivien mutanttien löytäminen tähän tarkoitukseen on kuitenkin hankalaa. 
% Tästä lisää?

\subsection{Mutanttianalyysin optimointi}
Myös yksittäisen mutanttien testausprosessia voidaan optimoida. Ensimmäinen luonnollinen optimointi on ajaa testit yksittäisiä mutantteja vasten rinnakkain. Toinen tekninen optimointi on ajaa vain tarvittavat testit jonkin mutantin tappamiseksi. Testien rivi- ja haarakattavuutta apuna käyttäen voidaan alkuperäisen ohjelman mutaatiokohta tiedettäessä ajaa vain ne testit, mitkä pystyvät tunnistamaan kyseisen mutaation. Jos jokin testi testaa täysin tästä mutaatiosta riippumatonta osaa koodissa, voidaan tämä testi olla ajamatta. Tämä optimointi on käytössä mm. Javalanche mutaatiotestauskehyksessä~\cite{}.

Mutanttien analysointi vie paljon aikaa erityisesti käännettävissä ohjelmointikielissä. Jokainen yksittäinen mutantti $m\in M$ pitää kääntää kun testit ajetaan tälle mutantille. Tämä ongelma voidaan helposti välttää tulkattavissa ohjelmointikielissä kuten Rubyssa ja Pythonissa, jotka ovat moderneja paljon käytettyjä \"skriptauskieliä\". Tulkattavissa kielissä voidaan ajaa ohjelmakoodi sellaisenaan, pitäen mielessä mutaatiokohta. Kun saavutaan mutatoidulle riville, tämä rivi suoritetaan sen mutatoidulla versiolla. Näin muistissa tarvitsee pitää vain mutatoitu rivi, sekä suoritus tapahtuu vain alkuperäistä ohjelmaa tulkkaamalla. Joissain mutaatiotestauskehyksissä ollaan simuloitu tätä käyttäytymistä käännettäville ohjelmointikielille. Javalanche~\cite{} on Java ohjelmille toteutettu mutaatiotestauskehys joka mutatoi suoraan Javan tavukoodia. Tällä vältytään jokaisen mutantin yksittäisellä kääntämiseltä ja päästään samaan vaikutukseen kuin tulkatuilla ohjelmointikielillä. Tavukoodin hyödyntämisen mutatoinnissa esittelivät ensimmäisen kerran Ma ja kumppanit~\cite{}. Aikaisemmin kääntämiseen kuluvan ajan vähentämiseksi tutkittiin ns. supermutanttien generointia, jossa alkuperäisestä ohjelmasta $O$ luodaan vain yksi mutantti, joka esittää kaikkia yksittäisiä mutantteja $m\in M$. Supermutantin kääntämällä joudutaan kääntämään vain yksi ohjelma. Supermutantti on kuitenkin kooltaan suurempi ja sen käsittelyn toteuttaminen hankalaa. Tavukoodin mutatointi suoraan on paljon yksinkertaisempi ja vähintään yhtä tehokas vaihtoehto. Tavukoodin mutatointikaan ei ole helppoa tai mahdollista kaikissa tapauksissa, joten näissä tapauksissa supermutanttien käyttäminen voi olla houkutteleva vaihtoehto.

\section{Ekvivalentit mutantit}
Ekvivalentit mutantit ovat alkuperäisen ohjelman mutantteja, jotka ovat toiminnallisuudeltaan kuitenkin täysin vastaavia alkuperäisen ohjelman kanssa, kuten äärellisten automaattien tapauksessa. Niiden läsnäolo johtaa siihen, ettei mutaatiokattavuus ole 100\%, vaikka todellisuudessa testit kattavat kaikki epäekvivalentit mutantit. Ekvivalenttien mutanttien tunnistaminen manuaalisesti on rasittavaa ja aikaavievää~\cite{}. Formaalimmin ekvivalenssi voidaan määritellä siten, että jos alkuperäinen ohjelma ajatellaan funktiona $O$ ja mutantti funktiona $M$, niiden tulosteet ovat samat kaikille syötteille $s$, eli $\forall s(O(s) = M(s))$. Ei siis ole olemassa testiä $T$ joka erottaa mutantin $M$ alkuperäisestä ohjelmasta $O$. Lisäksi, on kokeellisesti huomattu, että jos ekvivalenssia ei tutkita tarkkaan, voidaan tehdä virheitä ja leimata joitain tapettavia mutantteja ekvivalenteiksi. Huolimaton selviytyneiden mutanttien tarkastelu voi siis antaa myös päinvastaiseen suuntaan virheellisen kuvan testien kattavuudesta, ja pahimmillaan johtaa liikaan luottamukseen ohjelman toimivuudesta. % Tähän jotain viiteitä ja oikeita lukuja

% LOLWAT, miten tää liittyy seuraavaan?
Ekvivalenttien mutanttien tunnistaminen automaattisesti on hankalaa. Voidaan jopa osoittaa, että kahden ohjelman ekvivalenssin tarkistaminen on päättelemätön ongelma. Alhaisten asteitten mutantit ovat kuitenkin erikoistapauksia tästä ongelmasta, sillä tällöin mutantti poikkea alkuperäisestä ohjelmasta hyvin pienissä määrin. Voidaankin osoittaa, että useissa tapauksissa ekvivalenssi voidaan päätellä algoritmisesti, ja muissa tapauksissa voidaan käyttää erilaisia tekniikoita ekvivalenssin estimoimiseen. 

\subsection{Selviytyneiden mutanttien järjestäminen}
Zeller ja kumppanit ovat tutkiteet miten ekvivalentit mutantit vaikuttavat ohjelman suoritukseen verrattuna tapettaviin mutantteihin. Käyttäen apuna jotakin mittaa mutantin vaikuksesta ohjelman suoritukseen voidaan saada jonkinlainen arvo, joka on jossain määrin rinnastettavissa siihen kuinka todennäköisesti tämä mutantti on ekvivalentti. Näitä mittoja ollaan hyödynnetty Javalanchessa listaamaan selviytyneet mutantit jonkin prioriteetin mukaan. Ne mutantit joilla tämä mitta on korkea, ovat todennäköisemmin tapettavissa, kuin ne joilla se on matala. Tämä mitta voi olla hyödyllinen ohjelmoijalle, joka yrittää päätellä mutantin ekvivalenssia. Mahdollisena mittana ollaan tutkittu lausekattavuutta, sekä ohjelmasta pääteltyjen invarianttien rikkomuksia.

Zeller ja kumppanit tutkivat yhdellä Javalla kirjoitetulla esimerkkiohjelmistolla miten mutaatioiden tuottamat muutokset koodikattavuuteen korreloivat tapettavuuden kanssa. Huomattiin, että suurin osa niistä mutanteista jotka vaikuttavat eniten koodikattavuuteen eivät ole ekvivalentteja. Vastaavasti iso osa niistä mutanteista jotka vaikuttavat kattavuuteen vähiten ovat ekvivalentteja. Mutanttien listaaminen tämän järjestelyn perusteella vaikuttaa siis alustavasti hyödylliseltä. Tutkimukesssa käytettiin kuitenkin vain yhtä ohjelmistoa, joten mitään isoja johtopäätöksiä on vaikea vetää.

Schuler ja kumppanit ovat vaihtoehtoista keinoa seitsemällä isokokoisella ohjelmistolla. Javalanche mutaatiotestauskehykseen liitettiin komponentti joka luo lähdekoodista syötetiedostoja DAIKONille~\cite{}, joka on ohjelmisto jonka tarkoituksena löytää invariantteja ohjelmistosta sille annettujen syötetiedostojen avulla. Generoiduista mutaatioista voidaan selvittää niiden rikkomien invarianttien määrä, ja pitää tätä mittana mutantin vaikutuksesta ohjelman toimintaan. Tilastollisen analyysin pohjalta Schuler ja kumppanit totesivat invariantteja rikkovien mutanttien olevan kaksi kertaa todennäköisemmin tapettavissa. Havaittiin seuraavaa: eniten invariantteja rikkovat mutantit ovat todennäköisemmin ekvivalentteja kuin vähiten invariantteja rikkovat~\cite{}.

\subsection{Mutanttien evoluutio}
% Lue uudestaan, aika epäselvä ja konflikteja tekstissä
Eräs keino vähentää mutanttien ekvivalenssia, ja oikeastaan välttää ekvivalenssi täysin, on generoida mutantit normaalista käytännöstä poiketen geneettistä algoritmia hyödyntäen. Alkuperäisohjelmasta luodaan joukko mutantteja $M$, joita aletaan sitten jalostamaan geneettisellä algoritmilla käyttäen mutantteihin erikoistunutta fitnessifunktiota. Fitnessifunktio on sellainen, että se rankaisee ekvivalentteja mutantteja niin paljon, että käytännössä niitä ei voi esiintyä millään mutanttien generaatiolla. Tämä tarkoittaa sitä, että valitun fitnessifunktion tulee olla sellainen, että ekvivalenttien mutanttien fitnessi on huono. Näin jokaisen generaation mutantti on aina tapettava. Geneettisen algoritmin hyödyntämistä mutanttien generoinnissa tutkivat Adampolous ja muut ovat esitelleet myös elitismin, joka on mutanttien tarkoitukseen erityisesti sopiva lisäys geneettiseen algoritmiin, jossa tietty määrä mutantteja selviää sellaisenaan seuraavaan generaatioon.

Geneettinen algoritmi takaa sen, ettei ekvivalentteja mutantteja synny, ja tulee toteuttaneeksi selektiivistä mutatointia. Tätä lähestymistapaa ei ole kuitenkaan vielä tutkittu kovinkaan kattavasti, eikä sen tehokkuudesta ole siis takeita. Lisäksi, geneettinen algoritmi yleisenä approksimointimenetelmänä tiedetään hitaaksi suorittaa. Mikäli halutaan joukko todella optimaalisia mutantteja, niiden aikaansaaminen voi viedä runsaasti aikaa, joka jälleen kasvaa räjähdysmäisesti ohjelman koon kasvaessa. On jopa todennäköistä, että se vie paljon kauemmin kuin traditionaalinen mutaatioestaus suuremmilla ohjelmistoilla, mikäli hyödynnetään jonkinalaista selektiivistä mutatointia. Vaikka siis onnistuttaisiinkin poistamaan ekvivalentit mutantit kokonaan, hävitään skaalautuvuutta, joka on jo valmiiksi mutaatioestauksen ongelmana. Ei myöskään koskaan voida saavuttaa täysin eksaktia mutaatiokattavuutta, sillä tästä menetelmästä selektiivistä mutatointia ei voi kytkeä pois päältä.

\subsection{Kääntäjän hyödyntäminen}
Ekvivalentteja mutantteja voidaan myös vähentää tunnistamalla niitä mitä voidaan. Eräs tapa on käyttää hyväksi käännettävien ohjelmointikielten kääntäjää. Kääntäjät suorittavat optimointeja käännettävälle koodille. Kun jokin mutaatio täyttää jonkin optimointisäännön, tai tuottaa käänteisen optimoinnin ohjelmaan, voidaan päättää että mutantti on ekvivalentti. Näin voidaan kuitenkin tunnistaa vain hyvin rajattu osa ekvivalenteista mutanteista. Lisäksi, moni nykyään käytetyistä ohjelmointikielistä on tulkittava, eikä käänettävä. 

\section{Mutaatiotestaus käytännössä: PITest}
PIT on on Java-kielelle kehitetty mutaatiotestauskehys joka saadaan integroitua paljon käytettyihin Javan projektinhallintatyökaluihin, kuten Maveniin. PIT on JUnit-kehyksen päälle rakennettu mutaatiotestikehys, joka tarjoaa automaattisen mutaatioiden generoinnin Java-projekteihin mutatoimalla Javan tavukoodia. PIT tunnistaa mutatoitavat luokat ja ohjelman pakkausrakenteesta löytyvät testit automaattisesti. Mutaatiotestaussyklin tuloksena on mutaatiokattavuusraportti, josta löytyy kiinteän kattavuusprosentin lisäksi jokaisen mutantin mutaatiokohta, mutaatiotyyppi, sekä tieto siitä onko mutantti tapettu vai ei. Nämä raportit ovat mutanttikohtaisia. Mutantit leimataan niiden tarkastelun jälkeen johonkin kuudesta eri luokasta: tapettu, selviytynyt, virheellinen, aikakatkaistu, muistivirhe, suoritusvirhe. Virheellisellä viitataan virheelliseen tavukoodiin. Aikakatkaistu mutantti taas usein viittaa loputtomaan silmukkaan. Muistivirhe ja suoritusvirhe viittaavat ajon aikana mahdollisiin Javan virtuaalikoneen tuottamiin virheisiin. Mutantti voi olla sellainen, että se johtaa virtuaalikoneen muistin ylikuormittamiseen, tai aiheuttaa virheitä koodin suorituksessa. Nämä mutantit voidaan siten jättää huomioimatta, eikä niitä leimata virheellisesti selviytyneiksi.

PIT suorittaa jokaiselle mutantille vain tarpeelliset testit Javalanchen tapaan tarkastellen testien rivikattavuutta säästääkseen resursseja. Rivikattavuuden lisäksi PIT hyödyntää testien nimeämiskonventioita ja niiden suoritusaikaa päättääkseen mitkä testit sen tulisi ajaa kutakin mutanttia analysoitaessa.

PITin mutatointi tapahtuu sen mutaattorien avulla. Mutaattorit ovat luokkia jotka soveltavat joitain hyvin samankaltaisia mutaatio-operaattoreita. Mutaattoreita on 13 kappaletta, joista kolme on vasta kokeiluvaiheessa. Konditionaalisten rajan mutaattori esimerkiksi vaihtaa $<$ operaattorit $<=$ operaattoreiksi, sekä toisin päin, ja tekee saman myös epäyhtälön toiseen suuntaan. Kontionaalisen rajan negatointi mutaattori vaihtaa kaikki loogiset operaattorit niiden negaatioiksi, esim. $==$ mutatoidaan $!=$, sekä $<$ mutatoidaan $>=$. Matematiikkamutaattori mutatoi minkä tahansa kokonais- tai liukulukujen aritmeettisen operaattorin toiseksi. Esimerkiksi $+$ operaattorista tulee $-$, $\&$ operaattorista tulee $|$ ja $\%$ operaattorista tulee $*$. Tarkempi lista näistä operaattoreista löytyy matematiikkamutaattorin operaattorilistauksesta~\cite{}. Kasvatusmutaattori vaihtaa muuttujan inkrementoinnit dekrementoinneiksi ja toisin päin. Paluuarvottomien metodikutsujen mutaattori poistaa metodikutsut joilla ei ole paluuarvoa. Paluuarvollisten metodikutsujen mutaattori korvaa jonkin metodin paluuarvon sen paluuarvon tyypin oletusarvolla. Kontruktorimutaattori korvaa kontruktorikutsut nullilla. Paluuarvomutaattori vaihtaa metodikutsujen paluuarvoja. Tässä listattiin vain ne mutaattorit jotka eivät ole kokeiluvaiheessa.

PIT-kehyksen kymmenestä epäeksperimentaalisesta mutaattorista seitsemän ovat oletukselta käytössä. Näistä mutaattoreista saatava mutaatio-operaattoreiden määrä ei ole yhtä laaja kuin aiemmin raportoidut kattavat luettelot olemassaolevista operaattoreista. PITin operaattorit on valittu siten, että ne ovat lähellä tyypillisiä ohjelmoijien virheitä, sekä siten että ne ovat mahdollisimman stabiileja. Stabiiliudella tässä yhteydessä viitataan siihen, että ne tuottavat mahdollisimman vähän ekvivalentteja mutantteja. PITin vahvuus on juuri tämä operaattorien valinta. Niiden vähyys takaa sen, että mutaatioanalyysi sujuu tarpeeksi nopeasti skaalautuakseen myös laajemille ohjelmistoille. Lisäksi stabiilit mutaatio-operaattorit takaavat ekvivalenttien mutanttien vähäisen määrän.

PIT tarjoaa myös viisi optimointia, jotka voidaan kytkeä päälle haluttaessa. Nämä optimoinnit ovat:
\begin{enumerate}
	\item Jos luokka jossa oli viime testisyklillä loputon silmukka ei ole muuttunut, todetaan että siinä on edelleen silmukka.
	\item Jos mutaatio tapettiin edellisessä syklissä, eivätkä mutatoitu luokka tai mutantin tappanut testi ole muuttuneet, todetaan että mutantti kuolee uudellakin syklillä.
	\item Jos mutantti selvisi edellisellä syklillä eikä sen testien kattavuuden alueella ole muutoksia, todetaan sen selviävän uudestaan. 
	\item Jos mutantti on tapettu edellisellä kierroksella ja sen tappanut testi on muuttunut, nostetaan tämä mutantti tärkeimmän prioriteetin mutantiksi.
	\item Jos jollain luokalla on useita selviytyneitä mutantteja viime syklissä, voidaan nämä mutaatiot ottaa käyttöön samanaikaisesti, ja ajaa testit tällä niinsanotulla metamutantilla. Mikäli tämä metamutantti ei kuole, pitää mutaatiot analysoida yksitellen. Jos taas tämä metamutantti tapetaan, säästetään suoritusaikaa ja todetaan, että kaikki kyseiset mutantit tapettaisiin myös yksitellen.
\end{enumerate}
Nämä optimoinnit kytkettyinä tehostavat PITin suorituskykyä ja skaalautuvuutta edelleen. Niitä ei kuitenkaan ole täysin viisasta käyttää, sillä neljättä optimointia lukuunottamatta ne voivat aiheuttaa virheellisen analyysin. Javassa luokkien käyttäytyminen ei riipu pelkästään sen omasta koodasta, vaan myös sen riippuvuuksista muihin luokkiin. Vaikka luokka itse ei olisi muuttunut, sen käyttäytyminen on voinut muuttua jos esimerkiksi jokin sen komposiiteistä on muuttunut. PIT ei havaitse muita muutoksia luokkaan kuin luokan itsensä, sekä sen perimien yliluokkien muutokset tavukoodista. Näitä optimointeja voidaan ottaa käyttöön luottamalla oletukseen, että luokkien käyttäytyminen muuttuu harvoin ilman, että sen oma lähdekoodi muuttuu. Viimeinen esitelty optimointi lisäksi tuo ylimääräisen riskin: mutantit voivat olla päälekkäisiä, jolloin ylikirjoittavan mutantin tappaminen ei välttämättä implikoi ylikirjoitetun mutantin tappamista.
% vois ehkä viel jotain tost PITin priorisoinnista jos löytyy
% jotain kuvia raporteista
% vois viel Javalanchestakin selittää jotain lyhyesti, että saa vertauskuvan, ehkä kuva siitäkin
% vois selittää jotain diibadaabaa siitä miksi raportit on sellasia kun on ja mitä hyötyä niistä on

\section{Mutaatiotestaus käytännössä: Cobertura}
Cobertura on yksi käytetyimmistä testauskattavuustyökaluista Java-ympäristöön. Se tarjoaa samantapaisen HTML muotoisen testikattavuusraportin kuin PIT. Tämä raportti kuitenkin sisältää vain raportin rivi- sekä haarakattavuudesta. Cobertura näyttää rivikattavuuden ja haarakattavuuden vierekkäisinä värityksinä jokaisella rivillä. Jos jollain rivillä on punaista, jomman kumman kattavuusmetriikan mukaan testeissä on puutteita. Kuitenkin kuten aiemmin todettiin, nämä kattavuusmetriikat eivät kuvaa testien kattavuutta kovinkaan hyvin. Raportista on kuitenkin helppo huomata jos kokonaisia osia koodista on jäänyt testeissä huomiotta, sekä mitkä nämä osat ovat. 

\section{Yhteenveto}


\end{document}
