\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{Mutaatiotestaus -- working title}
\author{Tony Kovanen}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
A.1 [Introductory and Survey],\\
I.7.m [Document and text processing]}}

\keywords{}

\mytableofcontents

\section{Johdanto}
Ohjelmistoja tuotettaessa on tärkeää validoida ohjelmiston eri komponenttien toimivuus, niiden yhteensopivuus, sekä järjestelmän toimivuus kokonaisuudessaan. Testauksen rooli ohjelmistotuotantoprosessissa vie potentiaalisesti paljon resursseja verrattuna muuhun prosessissa vaadittuun työmäärään, mutta se myös torjuu tehokkaasti viallista koodia~\cite{}. Vaikka testaus ei anna täysin objektiivista totuutta siitä toimiiko ohjelmisto kuten on odotettu, se kuitenkin kasvattaa sen luotettavuutta. Kattavien testien läsnäollessa voidaan myös huoletta lisätä uutta toiminnallisuutta, muokata vanhaa toiminnallisuutta, ja refaktoroida ohjelmakoodia, sillä epäonnistuvat testit indikoivat sitä, että jotain on rikottu näitä muutoksia tehtäessä, eikä koodin muokkaaminen näinollen tuo prosessiin yhtä paljon epävarmuutta ohjelmiston toimivuuden suhteen.

\subsection{Testauksen tasot}
Yksikkötesteillä huolehditaan siitä, että yksittäiset komponentit ohjelmistossa toimivat oikein. Näillä voidaan varmistaa olio-ohjelmointikielissä yksittäisten luokkien ja niiden metodien toimivuus. Vastaavia testejä voidaan kirjoittaa myös esimerkiksi funktionaalisiin ohjelmointikieliin, joissa yksikkötestit testaavat yksittäisten funktioiden toiminnallisuutta. Kattavien yksikkötestien läsnäollessa refaktorointi on helpompaa, sillä jokaisen muutoksen jälkeen voidaan ajaa yksikkötestit, ja saada välitöntä palautetta siitä toimiiko muutettu komponentti vieläki olennaisesti samalla tavalla.

Integraatiotestit testaavat komponenttien toimivuutta kokonaisuutena. Integraatiotestejä voidaan kirjoittaa useilla yksikkötesteihin ominaisilla testikehyksillä, mutta niitä varten on myös suunniteltu monia omia ohjelmakehityksiä. Integraatioestit on usein toteutettu ihmismäistä käyttäytymistä imitoiviksi, esimerkiksi selainympäristössä suoritettaville ohjelmistoille on kehitetty erilaisia kirjastoja, joilla voidaan avata ohjelmisto selaimessa, ja navigoida sivulla aivan kuten ihminen. Toimivuus voidaan sitten validoida odotettujen näkymien ja HTTP statuskoodien perusteella.

\subsection{Testikattavuus}
Niin yksikkö- kuin integraatiotestien yhteydessä puhutaan usein testikattavuudesta. Testikattavuus on mitta siitä, miten hyvin käytettävät testit kattavat komponenttien tarjoaman toiminnallisuuden, tai koko järjestelmälle määritellyn toiminnallisuuden. Kattavuuden mittana tunnetuimmat ja yleisimmät ovat rivikattavuus, ja haarakattavuus.

Rivikattavuus mittaa testattavasta komponetista testien käsittelemän ohjelmakoodin rivien määrän. Jos jonkin komponentin yksikkötestit suoritettaessa suorittavat jokaisen rivin komponentin ohjelmakoodista, on rivikattauus 100\%, ja pidetään komponentin testejä tämän metriikan nojalla kattavana.

Haarakattavuus mittaa eri kontrollirakenteista syntyvien haarojen kattavuuden, eli se kertoo prosentuaalisesti sen määrän eri kontrollihaaroista, minkä ohjelmakoodin testit ovat suorittaneet testattavasta komponentista. Jos jokainen haara käsitellään testeissä, ovat testit haarakattavuuden nojalla kattavat. Useimmiten testikattavuuden mittana käytetään näiden kahden mitan unionia, sillä molemmat ovat yksinään hyvin puutteellisia.

Rivi- ja haarakattavuuden lisäksi on olemassa muita mittoja testikattavuuden mittaamiseen, joista yksi on mutaatiokattavuus. Mutaatiokattavuudella pyritään semanttisempaan analyysin testien kattavuudesta. Mutaatioestauksen tavoite on saada selville kuinka kattavasti määritellyt testit löytävät ohjelmakoodiin indusoitavia pieniä muutoksia. Tässä tutkielmassa esitellään mutaatiotestaus, sen menetelmät, sovellukset ja heikkoudet.

\section{Mutaatiotestaus}
Mutaatioestaus tapahtuu ohjelmalle suoritettavalla testaussyklillä. Ensin ohjelman testit ajetaan alkuperäiselle lähdekoodille. Jos jokin testi epäonnistuu, pitää se korjata ennen jatkamista.

Seuraavaksi ohjelmakoodista tehdään useita kopioita, joissa joku yksityiskohta, tai joitain yksityiskohtia on muutettu niinsanotuilla mutaatioilla. Näitä kopioita kutsutaan mutanteiksi. Testit jotka on annettu mutaatiosyklin parametreina ajetaan jokaiselle mutantille. Jos jokin testi epäonnistuu mutantin kohdalla, tämä mutantti leimataan tapetuksi, sillä tämä testi tunnisti koodin tehdyn muutoksen. Jos taas mikään testi ei epäonnistu, mutantti leimataan selviytyjäksi, sillä mikään testi ei tunnistanut muutosta. Selvitytyneet mutantit kielivät usein puutteesta testeissä. Jokaisesta mutantista otetaan usein talteen mutaatiokohta, sekä mutaatio. Näin selviytynyeitä mutantteja voidaan tarkastella, ja testejä parannella selviytyneitä mutantteja apuna käyttäen. Ne antavat usein vihjeitä siitä mikä testeissä on puutteellista.

Mutaatiosykliin ollaan ehdoteltu parannuksia. Lupaavia lisäyksiä tutkitaan jatkuvasti, ja tulevaisuuden varalle ollaan ehdotettu seuraavaa pidennystä sykliin: kun selviytyvät mutantit ollaan löydetty generoidaan niiden perusteelta testejä automaattisesti. Toistetaan sitten sykliä alusta lähtien niin kauan kunnes yksikään mutantti ei jää henkiin. Tähän sykliin pääseminen ei ole kuitenkaan vielä mahdollista. Mutaatiotestaukseen liittyvät ongelmat käsitellään myöhemmissä kappaleissa.

\section{Mutaatiot}
Mutaatiotestaus perustuu siihen, että ohjelmakoodiin indusoidaan mutaatoita, joita ohjelmalle määriteltyjen testien tulisi huomata. Mutaatio tarkoittaa perinnöllisyystieteessä muutosta geeniin jossa yksi geenin kemiallinen komponentti, nulkeotidi, on vaihtunut joksikin toiseksi, on deletoitu sekvenssistä, tai on insertoitu sekvenssiin. Ohjelmakoodiin indusoitavat mutaatiot on toteutettu samalla idealla: koodista voidaan esim. poistaa yksittäisiä rivejä, muuntaa operaattoreita tai metodikutsuja toisiksi, tai lisätä ylimääräistä koodia. Mahdollisia mutaatoita on siis erittäin suuri määrä, ja laskennallisista syistä niistä voidaan käyttää vain osajoukkoa. Tyypilliset mutaatiot tuodaan esille myöhemmin tässä kappaleessa. Ensin kuitenkin esitellään mutaatioiden konsepti ja miten ne ilmenevät eri ohjemointikielissä.

\subsection{Mutaatiot äärellisillä automaateilla}
Mutaatiot on helppo esittää äärellisillä automaateilla. Olkoon $\Sigma={0,1}$ aakkosto. Voimme nyt määritellä tälle aakkostolle useita eri äärellisiä automaatteja, jotka hyväksyvät vain jotkin tietyt merkkijonot joka koostuvat aakkosista $\sigma \in \Sigma$. Eräs tällainen automaatti löytyy kuvasta~\ref{fig:nfa}, jonka aloitustila on tila $a$ ja hyväksyvä tila on tila $e$. Määritellään nyt myös joukko mutaatioita $M$. Jokainen mutaatio $m\in M$ on kuvaus, joka korvaa jonkin olemassaolevan tilasiirtymän toisella, poistaa tilasiirtymän, tai lisää tilasiirtymän. Näitä funktioita kutsutaan mutaatio-operaattoreiksi. Jokainen mutaatio $m$ on siis kuvaus aakkoston $\Sigma$ äärellisten automaattien joukolta itselleen, jossa tämä mutaatio tekee jonkn muutoksen, tai joitakin muutoksia annettuun äärelliseen automaattiin. 
% Tähän määritellään jokin aakkosto, jokin joukko mutaatioita, ja jokin automaatti, sitten näytetään miten näitä mutaatioita käyttäen voidaan luoda n määärä mutatoituja automaatteja

\subsection{Mutaatiot ohjelmointikielissä}

\subsection{Tyypilliset mutaatiot}
Kuten mainittu, mutaatioita on monia eri tyyppejä.

\subsection{Mutaatiot eri ohjemointiparadigmoissa}

\section{Sovellukset}

\section{Heikkudet}
Mutaatiotestaus ei ole täysin ongelmatonta. Ohjelman koon kasvaessa mutaatioiden generointi hidastuu. Suurimmaksi ongelmaksi on kuitenkin havaittu niin sanottujen ekvivalenttien mutanttien tunnistaminen. Ekvivalentit mutantit haittaavat mutaatiokattavuuden oikeellisuutta, ja niiden tunnistaminen pitää pahimmassa tapauksessa tehdä käsin. Niiden määrä saattaa olla niin suuri, että ekvivalenssin toteaminen vie useita työtunteja per mutantti. Nämä ongelmat selvitetään tässä kappaleessa tarkemmin, sekä esitellään joitain ratkaisuyrityksiä näihin ongelmiin.

\subsection{Aikavaativuus}
\subsection{Ekvivalentit mutantit}
Ekvivalentit mutantit ovat alkuperäisen ohjelman mutantteja jotka ovat toiminnallisuudeltaan kuitenkin täysin vastaavia alkuperäisen ohjelman kanssa. Niiden läsnäolo johtaa siihen, ettei mutaatiokattavuus ole 100\%, vaikka todellisuudessa testit olisivat niin kattavat. Ekvivalenttien mutanttien tunnistaminen manuaalisesti on rasittavaa ja aikaavievää. Lisäksi, on huomattu, että jos ekvivalenssia ei tutkita tarkkaan, voidaan tehdä virheitä ja leimata joitain tapettavia mutantteja ekvivalenteiksi. % Tähän jotain viiteitä ja oikeita lukuja

Ekvivalenttien mutanttien tunnistaminen automaattisesti on hankalaa. Voidaan jopa osoittaa, että kahden ohjelman ekvivalenssin tarkistaminen on päättelemätön ongelma. Alhaisten asteitten mutantit ovat kuitenkin erikoistapauksia tästä ongelmasta, sillä tällöin mutantti poikkea alkuperäisestä ohjelmasta hyvin pienissä määrin. Voidaankin osoittaa, että useissa tapauksissa ekvivalenssi voidaan päätellä algoritmisesti, ja muissa tapauksissa voidaan käyttää erilaisia tekniikoita ekvivalenssin estimoimiseen. 

\subsection{Kääntäjän hyödyntäminen}

Eräs tapa löytää ekvivalentteja mutantteja on käyttää hyväksi käännettävien ohjelmointikielten kääntäjää. Kääntäjät suorittavat optimointeja käännettävälle koodille. Kun jokin mutaatio täyttää jonkin optimointisäännön, tai tuottaa käänteisen optimoinnin ohjelmaan, voidaan päättää että mutantti on ekvivalentti. Näin voidaan kuitenkin tunnistaa vain hyvin rajattu osa ekvivalenteista mutanteista. Lisäksi, moni nykyään käytetyistä ohjelmointikielistä on tulkittava, eikä käänettävä. Tämä tuottaa ongelmia tälle ekvivalenssintunnistusmenetelmälle. 
% vois esitellä CBT

\subsection{Mahdollisen polun ongelma}
Ekvivalenssin tunnistusta voidaan myös lähestyä mahdollisen polun ongelman laajennoksena testeille. Mahdollisen testin ongelma on löytää onko olemassa jokin syöte, joka voi täyttää testin asettamat vaatimukset. Mahdollisen polun ongelma on kuitenkin päättelemätön. Tämän ongelman ratkaisuun on siis käytettävä approksimontialgoritmeja. Offut ja Pan ovat tarkastelleet erilaisia matemaattisia rajoitteita mahdottomien polkujen löytämiseksi. 



\section{Yhteenveto}


\end{document}
